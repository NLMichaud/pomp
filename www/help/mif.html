<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Maximum likelihood by iterated filtering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for Iterated filtering {pomp}"><tr><td>Iterated filtering {pomp}</td><td align="right">R Documentation</td></tr></table>

<h2>Maximum likelihood by iterated filtering</h2>

<h3>Description</h3>

<p>Iterated filtering algorithms for estimating the parameters of a partially-observed Markov process.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'pomp'
mif(object, Nmif = 1, start, ivps = character(0),
    particles, rw.sd, Np, ic.lag, var.factor = 1,
    cooling.type, cooling.fraction,
    method = c("mif","unweighted","fp","mif2"),
    tol = 1e-17, max.fail = Inf,
    verbose = getOption("verbose"), transform = FALSE, ...)
## S4 method for signature 'pfilterd.pomp'
mif(object, Nmif = 1, Np, tol, ...)
## S4 method for signature 'mif'
mif(object, Nmif, start, ivps,
    particles, rw.sd, Np, ic.lag, var.factor,
    cooling.type, cooling.fraction,
    method, tol, transform, ...)
## S4 method for signature 'mif'
continue(object, Nmif = 1, ...)
## S4 method for signature 'mif'
logLik(object, ...)
## S4 method for signature 'mif'
conv.rec(object, pars, transform = FALSE, ...)
## S4 method for signature 'mifList'
conv.rec(object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>

<p>An object of class <code>pomp</code>.
</p>
</td></tr>
<tr valign="top"><td><code>Nmif</code></td>
<td>

<p>The number of filtering iterations to perform.
</p>
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>

<p>named numerical vector;
the starting guess of the parameters.
</p>
</td></tr>
<tr valign="top"><td><code>ivps</code></td>
<td>

<p>optional character vector naming the initial-value parameters (IVPs) to be estimated.
Every parameter named in <code>ivps</code> must have a positive random-walk standard deviation specified in <code>rw.sd</code>.
If there are no non-IVP parameters with positive <code>rw.sd</code>, i.e., only IVPs are to be estimated, see below &ldquo;&quot;Using <code>mif</code> to estimate initial-value parameters only&quot;&rdquo;.
</p>
</td></tr>
<tr valign="top"><td><code>particles</code></td>
<td>

<p>Function of prototype <code>particles(Np,center,sd,...)</code> which sets up the starting particle matrix by drawing a sample of size <code>Np</code> from the starting particle distribution centered at <code>center</code> and of width <code>sd</code>.
If <code>particles</code> is not supplied by the user, the default behavior is to draw the particles from a multivariate normal distribution with mean <code>center</code> and standard deviation <code>sd</code>.
</p>
</td></tr>
<tr valign="top"><td><code>rw.sd</code></td>
<td>

<p>numeric vector with names; the intensity of the random walk to be applied to parameters.
The random walk is only applied to parameters named in <code>pars</code> (i.e., not to those named in <code>ivps</code>).
The algorithm requires that the random walk be nontrivial, so each element in <code>rw.sd[pars]</code> must be positive.
<code>rw.sd</code> is also used to scale the initial-value parameters (via the <code>particles</code> function).
Therefore, each element of <code>rw.sd[ivps]</code> must be positive.
The following must be satisfied:
<code>names(rw.sd)</code> must be a subset of <code>names(start)</code>,
<code>rw.sd</code> must be non-negative (zeros are simply ignored),
the name of every positive element of <code>rw.sd</code> must be in either <code>pars</code> or <code>ivps</code>.
</p>
</td></tr>
<tr valign="top"><td><code>Np</code></td>
<td>

<p>the number of particles to use in filtering.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timestep, one may specify <code>Np</code> either as a vector of positive integers (of length <code>length(time(object,t0=TRUE))</code>) or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on, while when <code>T=length(time(object,t0=TRUE))</code>,
<code>Np(T)</code> is the number of particles to sample at the end of the time-series.
</p>
</td></tr>
<tr valign="top"><td><code>ic.lag</code></td>
<td>

<p>a positive integer;
the timepoint for fixed-lag smoothing of initial-value parameters.
The <code>mif</code> update for initial-value parameters consists of replacing them by their filtering mean at time <code>times[ic.lag]</code>, where <code>times=time(object)</code>.
It makes no sense to set <code>ic.lag&gt;length(times)</code>;
if it is so set, <code>ic.lag</code> is set to <code>length(times)</code> with a warning.
</p>
<p>For <code>method="mif2"</code>, the default is <code>ic.lag=length(times)</code>.
</p>
</td></tr>
<tr valign="top"><td><code>var.factor</code></td>
<td>

<p>a positive number;
the scaling coefficient relating the width of the starting particle distribution to <code>rw.sd</code>.
In particular, the width of the distribution of particles at the start of the first <code>mif</code> iteration will be <code>random.walk.sd*var.factor</code>.
</p>
</td></tr>
<tr valign="top"><td><code>cooling.type, cooling.fraction</code></td>
<td>

<p>specifications for the cooling schedule, i.e., the manner in which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
</p>
<p>When <code>cooling.type="geometric"</code>, on the n-th <code>mif</code> iteration, the relative perturbation intensity is <code>cooling.fraction^(n/50)</code>.
</p>
<p>When <code>cooling.type="hyperbolic"</code>, on the n-th <code>mif</code> iteration, the relative perturbation intensity is <code>(s+1)/(s+n)</code>, where <code>(s+1)/(s+50)=cooling.fraction</code>.
<code>cooling.fraction</code> is the relative magnitude of the parameter perturbations after 50 <code>mif</code> iterations.
</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>

<p><code>method</code> sets the update rule used in the algorithm.
<code>method="mif"</code> uses the iterated filtering update rule (Ionides 2006, 2011);
<code>method="unweighted"</code> updates the parameter to the unweighted average of the filtering means of the parameters at each time;
<code>method="fp"</code> updates the parameter to the filtering mean at the end of the time series.
<code>method="mif2"</code> implements an incomplete version of the iterated Bayes map method of Ionides (2015).
The latter method is, by every indication, both more efficient and more stable.
</p>
</td></tr>
<tr valign="top"><td><code>tol, max.fail</code></td>
<td>

<p>See the description under <code><a href="pfilter.html">pfilter</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>

<p>logical; if TRUE, print progress reports.
</p>
</td></tr>
<tr valign="top"><td><code>transform</code></td>
<td>

<p>logical;
if <code>TRUE</code>, optimization is performed on the transformed scale, as defined by the user-supplied parameter transformations (see <code><a href="pomp.html">pomp</a></code>).
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>additional arguments that override the defaults.
</p>
</td></tr>
<tr valign="top"><td><code>pars</code></td>
<td>
<p>names of parameters.</p>
</td></tr>
</table>


<h3>Re-running <code>mif</code> Iterations</h3>

<p>To re-run a sequence of <code>mif</code> iterations, one can use the <code>mif</code> method on a <code>mif</code> object.
By default, the same parameters used for the original <code>mif</code> run are re-used (except for <code>weighted</code>, <code>tol</code>, <code>max.fail</code>, and <code>verbose</code>, the defaults of which are shown above).
If one does specify additional arguments, these will override the defaults.
</p>


<h3>Continuing <code>mif</code> Iterations</h3>

<p>One can resume a series of <code>mif</code> iterations from where one left off using the <code>continue</code> method.
A call to <code>mif</code> to perform <code>Nmif=m</code> iterations followed by a call to <code>continue</code> to perform <code>Nmif=n</code> iterations will produce precisely the same effect as a single call to <code>mif</code> to perform <code>Nmif=m+n</code> iterations.
By default, all the algorithmic parameters are the same as used in the original call to <code>mif</code>.
Additional arguments will override the defaults.
</p>


<h3>Using <code>mif</code> to estimate initial-value parameters only</h3>

<p>One can use <code>mif</code>'s fixed-lag smoothing to estimate only initial value parameters (IVPs).
In this case, <code>pars</code> is left empty and the IVPs to be estimated are named in <code>ivps</code>.
If <code>theta</code> is the current parameter vector, then at each <code>mif</code> iteration, <code>Np</code> particles are drawn from a distribution centered at <code>theta</code> and with width proportional to <code>var.factor*rw.sd</code>, a particle filtering operation is performed, and <code>theta</code> is replaced by the filtering mean at <code>time(object)[ic.lag]</code>.
Note the implication that, when <code>mif</code> is used in this way on a time series any longer than <code>ic.lag</code>, unnecessary work is done.
If the time series in <code>object</code> is longer than <code>ic.lag</code>, consider replacing <code>object</code> with <code>window(object,end=ic.lag)</code>. 
</p>


<h3>Methods</h3>

<p>Methods that can be used to manipulate, display, or extract information from a <code>mif</code> object:
</p>

<dl>
<dt>conv.rec</dt><dd>
<p><code>conv.rec(object, pars = NULL)</code> returns the columns of the convergence-record matrix corresponding to the names in <code>pars</code>.
By default, all rows are returned.
</p>
</dd>
<dt>logLik</dt><dd>
<p>Returns the value in the <code>loglik</code> slot.
NB: this is <EM>not</EM> the same as the likelihood of the model at the MLE!
</p>
</dd>
<dt>c</dt><dd>
<p>Concatenates <code>mif</code> objects into an <code>mifList</code>.
</p>
</dd>
<dt>plot</dt><dd>
<p>Plots a series of diagnostic plots when applied to a <code>mif</code> or <code>mifList</code> object.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>If <code>particles</code> is not specified, the default behavior is to draw the particles from a multivariate normal distribution.
<STRONG>It is the user's responsibility to ensure that, if the optional <code>particles</code> argument is given, that the <code>particles</code> function satisfies the following conditions:</STRONG>
</p>
<p><code>particles</code> has at least the following arguments:
<code>Np</code>, <code>center</code>, <code>sd</code>, and <code>...</code>.
<code>Np</code> may be assumed to be a positive integer;
<code>center</code> and <code>sd</code> will be named vectors of the same length.
Additional arguments may be specified;
these will be filled with the elements of the <code>userdata</code> slot of the underlying <code>pomp</code> object (see <code><a href="pomp.html">pomp</a></code>).
</p>
<p><code>particles</code> returns a <code>length(center)</code> x <code>Np</code> matrix with rownames matching the names of <code>center</code> and <code>sd</code>.
Each column represents a distinct particle.
</p>
<p>The center of the particle distribution returned by <code>particles</code> should be <code>center</code>.
The width of the particle distribution should vary monotonically with <code>sd</code>.
In particular, when <code>sd=0</code>, the <code>particles</code> should return matrices with <code>Np</code> identical columns, each given by the parameters specified in <code>center</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King <a href="mailto:kingaa at umich dot edu">kingaa at umich dot edu</a></p>


<h3>References</h3>

<p>E. L. Ionides, C. Breto, &amp; A. A. King,
Inference for nonlinear dynamical systems,
Proc. Natl. Acad. Sci. U.S.A., 103:18438&ndash;18443, 2006.
</p>
<p>E. L. Ionides, A. Bhadra, Y. Atchad\'e, &amp; A. A. King,
Iterated filtering,
Annals of Statistics, 39:1776&ndash;1802, 2011.
</p>
<p>E. L. Ionides, D. Nguyen, Y. Atchad\'e, S. Stoev, and A. A. King. 
Inference for dynamic and latent variable models via iterated, perturbed Bayes maps.
Proc. Natl. Acad. Sci. U.S.A., 112:719&ndash;724, 2015.
</p>
<p>A. A. King, E. L. Ionides, M. Pascual, and M. J. Bouma,
Inapparent infections and cholera dynamics,
Nature, 454:877&ndash;880, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="pomp.html">pomp</a></code>, <code><a href="pfilter.html">pfilter</a></code>
</p>

<hr><div align="center">[Package <em>pomp</em> version 0.62-5 <a href="00Index.html">Index</a>]</div>
</body></html>
