<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Some useful probes for partially-observed Markov processes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for Probe functions {pomp}"><tr><td>Probe functions {pomp}</td><td align="right">R Documentation</td></tr></table>

<h2>Some useful probes for partially-observed Markov processes</h2>

<h3>Description</h3>

<p>Several simple and configurable probes are provided with in the package.
These can be used directly and as templates for custom probes.
</p>


<h3>Usage</h3>

<pre>
probe.mean(var, trim = 0, transform = identity, na.rm = TRUE)
probe.median(var, na.rm = TRUE)
probe.var(var, transform = identity, na.rm = TRUE)
probe.sd(var, transform = identity, na.rm = TRUE)
probe.marginal(var, ref, order = 3, diff = 1, transform = identity)
probe.nlar(var, lags, powers, transform = identity)
probe.acf(var, lags, type = c("covariance", "correlation"),
          transform = identity)
probe.ccf(vars, lags, type = c("covariance", "correlation"),
          transform = identity)
probe.period(var, kernel.width, transform = identity)
probe.quantile(var, prob, transform = identity)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>var, vars</code></td>
<td>

<p>character; the name(s) of the observed variable(s).
</p>
</td></tr>
<tr valign="top"><td><code>trim</code></td>
<td>

<p>the fraction of observations to be trimmed (see <code><a href="../../base/html/mean.html">mean</a></code>).
</p>
</td></tr>
<tr valign="top"><td><code>transform</code></td>
<td>

<p>transformation to be applied to the data before the probe is computed.
</p>
</td></tr>
<tr valign="top"><td><code>na.rm</code></td>
<td>

<p>if <code>TRUE</code>, remove all NA observations prior to computing the probe.
</p>
</td></tr>
<tr valign="top"><td><code>kernel.width</code></td>
<td>

<p>width of modified Daniell smoothing kernel to be used in power-spectrum computation:
see <code><a href="../../stats/html/kernel.html">kernel</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>prob</code></td>
<td>

<p>a single probability; the quantile to compute: see <code><a href="../../stats/html/quantile.html">quantile</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>lags</code></td>
<td>

<p>In <code>probe.ccf</code>, a vector of lags between time series.
Positive lags correspond to <code>x</code> advanced relative to <code>y</code>;
negative lags, to the reverse.
</p>
<p>In <code>probe.nlar</code>, a vector of lags present in the nonlinear autoregressive model that will be fit to the actual and simulated data.
See Details, below, for a precise description.
</p>
</td></tr>
<tr valign="top"><td><code>powers</code></td>
<td>

<p>the powers of each term (corresponding to <code>lags</code>) in the the nonlinear autoregressive model that will be fit to the actual and simulated data.
See Details, below, for a precise description.
</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>

<p>Compute autocorrelation or autocovariance?
</p>
</td></tr>
<tr valign="top"><td><code>ref</code></td>
<td>

<p>empirical reference distribution.
Simulated data will be regressed against the values of <code>ref</code>, sorted and, optionally, differenced.
The resulting regression coefficients capture information about the shape of the marginal distribution.
A good choice for <code>ref</code> is the data itself.
</p>
</td></tr>
<tr valign="top"><td><code>order</code></td>
<td>

<p>order of polynomial regression.
</p>
</td></tr>
<tr valign="top"><td><code>diff</code></td>
<td>

<p>order of differencing to perform.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Additional arguments to be passed through to the probe computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of these functions is relatively simple.
See the source code for a complete understanding of what each does.
</p>

<dl>
<dt><code>probe.mean</code>, <code>probe.median</code>, <code>probe.var</code>, <code>probe.sd</code></dt><dd>
<p>return functions that compute the mean, median, variance, and standard deviation of variable <code>var</code>, respectively.
</p>
</dd>
<dt><code>probe.period</code></dt><dd>
<p>returns a function that estimates the period of the Fourier component of the <code>var</code> series with largest power.
</p>
</dd>
<dt><code>probe.marginal</code></dt><dd>
<p>returns a function that
regresses the marginal distribution of variable <code>var</code> against the reference distribution <code>ref</code>.
If <code>diff&gt;0</code>, the data and the reference distribution are first differenced <code>diff</code> times and centered.
Polynomial regression of order <code>order</code> is used.
This probe returns <code>order</code> regression coefficients (the intercept is zero).
</p>
</dd>
<dt><code>probe.nlar</code></dt><dd>
<p>returns a function that
fit a nonlinear (polynomial) autoregressive model to the univariate series (variable <code>var</code>).
Specifically, a model of the form <i>y[t] = &sum; beta[k] y[t-tau[k]]^p[k]+e[t]</i> will be fit, where <i>tau[k]</i> are the <code>lags</code> and <i>p[k]</i> are the <code>powers</code>.
The data are first centered.
This function returns the regression coefficients, <i>beta[k]</i>.
</p>
</dd>
<dt><code>probe.acf</code></dt><dd>
<p>returns a function that,
if <code>type=="covariance"</code>, computes the autocovariance of variable <code>var</code> at lags <code>lags</code>;
if <code>type=="correlation"</code>, computes the autocorrelation of variable <code>var</code> at lags <code>lags</code>.
</p>
</dd>
<dt><code>probe.ccf</code></dt><dd>
<p>returns a function that,
if <code>type=="covariance"</code>, computes the cross covariance of the two variables named in <code>vars</code> at lags <code>lags</code>;
if <code>type=="correlation"</code>, computes the cross correlation.
</p>
</dd>
<dt><code>probe.quantile</code></dt><dd>
<p>returns a function that estimates the <code>prob</code>-th quantile of variable <code>var</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A call to any one of these functions returns a probe function, suitable for use in <code><a href="probe.html">probe</a></code> or <code><a href="probe.html">probe.match</a></code>.
That is, the function returned by each of these takes a data array (such as comes from a call to <code><a href="pomp-methods.html">obs</a></code>) as input and returns a single numerical value.
</p>


<h3>Author(s)</h3>

<p>Daniel C. Reuman (d.reuman at imperial dot ac dot uk)
</p>
<p>Aaron A. King (kingaa at umich dot edu)
</p>


<h3>References</h3>

<p>B. E. Kendall, C. J. Briggs, W. M. Murdoch, P. Turchin, S. P. Ellner, E. McCauley, R. M. Nisbet, S. N. Wood
Why do populations cycle? A synthesis of statistical and mechanistic modeling approaches,
Ecology, 80:1789&ndash;1805, 1999.
</p>
<p>S. N. Wood
Statistical inference for noisy nonlinear ecological dynamic systems,
Nature, 466: 1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p><a href="pomp.html">pomp</a>
</p>

<hr><div align="center">[Package <em>pomp</em> version 0.62-5 <a href="00Index.html">Index</a>]</div>
</body></html>
