
R version 2.8.1 (2008-12-22)
Copyright (C) 2008 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(pomp)
Loading required package: deSolve
Loading required package: subplex
Loading required package: mvtnorm
> 
> set.seed(45768683)
> 
> rw.rprocess <- function (params, xstart, times, ...) { 
+   ## this function simulates two independent random walks with intensities s1, s2
+   nvars <- nrow(xstart)
+   nreps <- ncol(params)
+   ntimes <- length(times)
+   dt <- diff(times)
+   x <- array(0,dim=c(nvars,nreps,ntimes))
+   rownames(x) <- rownames(xstart)
+   noise.sds <- params[c('s1','s2'),]
+   x[,,1] <- xstart
+   for (j in 2:ntimes) {
+     ## we are mimicking a continuous-time process, so the increments have SD ~ sqrt(dt)
+     ## note that we do not have to assume that 'times' are equally spaced
+     x[c("x1","x2"),,j] <- rnorm(
+                                 n=2*nreps,
+                                 mean=x[c("x1","x2"),,j-1],
+                                 sd=noise.sds*dt[j-1]
+                                 )
+   }
+   x
+ }
> 
> rw.dprocess <- function (x, times, params, log = FALSE, ...) { 
+   ## given a sequence of consecutive states in 'x', this function computes the p.d.f.
+   nreps <- ncol(params)
+   ntimes <- length(times)
+   dt <- diff(times)
+   d <- array(0,dim=c(2,nreps,ntimes-1))
+   noise.sds <- params[c('s1','s2'),]
+   for (j in 2:ntimes)
+     d[,,j-1] <- dnorm(x[,,j]-x[,,j-1],mean=0,sd=noise.sds*dt[j-1],log=TRUE)
+   d <- apply(d,c(2,3),sum)
+   if (log) d else exp(d)
+ }
> 
> bvnorm.rmeasure <- function (t, x, params, ...) {
+   ## noisy observations of the two walks with common noise SD 'tau'
+   c(
+     y1=rnorm(n=1,mean=x['x1'],sd=params['tau']),
+     y2=rnorm(n=1,mean=x['x2'],sd=params['tau'])
+     )
+ }
> 
> bvnorm.dmeasure <- function (y, x, t, params, log = FALSE, ...) {
+   f <- sum(
+            dnorm(
+                  x=y[c("y1","y2")],
+                  mean=x[c("x1","x2")],
+                  sd=params["tau"],
+                  log=TRUE
+                  ),
+            na.rm=TRUE
+            )
+   if (log) f else exp(f)
+ }
> 
> bad.initializer <- function (params, t0, ...) 
+ {
+   ivpnames <- c("x1.0","x2.0")
+   x <- params[ivpnames]
+   x
+ }
> 
> p <- rbind(s1=c(2,2,3),s2=c(0.1,1,2),tau=c(1,5,0),x1.0=c(0,0,5),x2.0=c(0,0,0))
> 
> rw2 <- pomp(
+             rprocess = rw.rprocess,
+             dprocess = rw.dprocess,
+             measurement.model=list(
+               y1 ~ norm(mean=x1,sd=tau),
+               y2 ~ norm(mean=x2,sd=tau)
+             ),
+             initializer=bad.initializer,
+             times=1:100,
+             data=rbind(
+               y1=rep(0,100),
+               y2=rep(0,100)
+               ),
+             t0=0,
+             useless=23
+             )
> 
> show(rw2)
    time y1 y2
1      1  0  0
2      2  0  0
3      3  0  0
4      4  0  0
5      5  0  0
6      6  0  0
7      7  0  0
8      8  0  0
9      9  0  0
10    10  0  0
11    11  0  0
12    12  0  0
13    13  0  0
14    14  0  0
15    15  0  0
16    16  0  0
17    17  0  0
18    18  0  0
19    19  0  0
20    20  0  0
21    21  0  0
22    22  0  0
23    23  0  0
24    24  0  0
25    25  0  0
26    26  0  0
27    27  0  0
28    28  0  0
29    29  0  0
30    30  0  0
31    31  0  0
32    32  0  0
33    33  0  0
34    34  0  0
35    35  0  0
36    36  0  0
37    37  0  0
38    38  0  0
39    39  0  0
40    40  0  0
41    41  0  0
42    42  0  0
43    43  0  0
44    44  0  0
45    45  0  0
46    46  0  0
47    47  0  0
48    48  0  0
49    49  0  0
50    50  0  0
51    51  0  0
52    52  0  0
53    53  0  0
54    54  0  0
55    55  0  0
56    56  0  0
57    57  0  0
58    58  0  0
59    59  0  0
60    60  0  0
61    61  0  0
62    62  0  0
63    63  0  0
64    64  0  0
65    65  0  0
66    66  0  0
67    67  0  0
68    68  0  0
69    69  0  0
70    70  0  0
71    71  0  0
72    72  0  0
73    73  0  0
74    74  0  0
75    75  0  0
76    76  0  0
77    77  0  0
78    78  0  0
79    79  0  0
80    80  0  0
81    81  0  0
82    82  0  0
83    83  0  0
84    84  0  0
85    85  0  0
86    86  0  0
87    87  0  0
88    88  0  0
89    89  0  0
90    90  0  0
91    91  0  0
92    92  0  0
93    93  0  0
94    94  0  0
95    95  0  0
96    96  0  0
97    97  0  0
98    98  0  0
99    99  0  0
100  100  0  0
zero time, t0 = 0
parameter(s) unspecified
process model simulator, rprocess = 
function (params, xstart, times, ...) 
{
    nvars <- nrow(xstart)
    nreps <- ncol(params)
    ntimes <- length(times)
    dt <- diff(times)
    x <- array(0, dim = c(nvars, nreps, ntimes))
    rownames(x) <- rownames(xstart)
    noise.sds <- params[c("s1", "s2"), ]
    x[, , 1] <- xstart
    for (j in 2:ntimes) {
        x[c("x1", "x2"), , j] <- rnorm(n = 2 * nreps, mean = x[c("x1", 
            "x2"), , j - 1], sd = noise.sds * dt[j - 1])
    }
    x
}
process model density, dprocess = 
function (x, times, params, log = FALSE, ...) 
{
    nreps <- ncol(params)
    ntimes <- length(times)
    dt <- diff(times)
    d <- array(0, dim = c(2, nreps, ntimes - 1))
    noise.sds <- params[c("s1", "s2"), ]
    for (j in 2:ntimes) d[, , j - 1] <- dnorm(x[, , j] - x[, 
        , j - 1], mean = 0, sd = noise.sds * dt[j - 1], log = TRUE)
    d <- apply(d, c(2, 3), sum)
    if (log) 
        d
    else exp(d)
}
measurement model simulator, rmeasure = 
function (x, t, params, covars, ...) 
{
    y <- numeric(length = nobs)
    names(y) <- obsnames
    for (k in 1:nobs) {
        y[k] <- eval(rcalls[[k]], envir = as.list(c(x, params, 
            covars, t = t)))
    }
    y
}
<environment: 0x17d8bd8>
measurement model density, dmeasure = 
function (y, x, t, params, log, covars, ...) 
{
    f <- 0
    for (k in 1:nobs) {
        f <- f + eval(dcalls[[k]], envir = as.list(c(y, x, params, 
            covars, t = t)))
    }
    if (log) 
        f
    else exp(f)
}
<environment: 0x17d8bd8>
initializer = 
function (params, t0, ...) 
{
    ivpnames <- c("x1.0", "x2.0")
    x <- params[ivpnames]
    x
}
userdata = 
$useless
[1] 23

> 
> try(
+     simulate(rw2,params=p)
+     )
Error in try(.Call(do_init_state, object, as.matrix(params), t0), silent = FALSE) : 
  a state variable and a parameter share a single name: 'x1.0'
Error : init.state error: error in user ‘initializer’
> 
> rw2 <- pomp(
+             rprocess = rw.rprocess,
+             dprocess = rw.dprocess,
+             measurement.model=list(
+               y1 ~ norm(mean=x1,sd=tau),
+               y2 ~ norm(mean=x2,sd=tau)
+             ),
+             times=1:100,
+             data=rbind(
+               y1=rep(0,100),
+               y2=rep(0,100)
+               ),
+             t0=0,
+             useless=23
+             )
> 
> examples <- simulate(rw2,params=p)
> rw2 <- examples[[1]]
> 
> y <- simulate(rw2,params=p,obs=T,states=T)
> y <- simulate(rw2,params=p,obs=T)
> x <- simulate(rw2,params=p,states=T)
> x <- simulate(rw2,nsim=10,params=p,states=T)
> x <- simulate(rw2,nsim=10,params=p[,1],states=T)
> x <- simulate(rw2,nsim=10,params=p[,1],obs=T,states=T)
> x <- simulate(rw2,nsim=10,params=p[,1],obs=T,states=T)
> x <- simulate(rw2,nsim=10,params=p,obs=T,states=T)
> x <- simulate(rw2,nsim=10,params=p[,1])
> 
> x <- data.array(rw2)
> t <- time(rw2)
> 
> x0 <- init.state(rw2,params=p)
> x <- rprocess(rw2,xstart=x0,times=0:100,params=p)
> y <- rmeasure(rw2,x=x,times=0:100,params=p)
> 
> log(dprocess(rw2,x[,,6:11],times=5:10,params=p))
           [,1]       [,2]       [,3]       [,4]      [,5]
[1,] -0.3528305 -0.2613777 -0.2447111 -0.2408028 -1.048260
[2,] -3.0433899 -3.1306252 -2.6601367 -5.0275855 -2.596964
[3,] -3.8848651 -4.1398497 -3.6984915 -3.8832277 -6.917348
> dprocess(rw2,x[,,6:11],times=5:10,params=p,log=T)
           [,1]       [,2]       [,3]       [,4]      [,5]
[1,] -0.3528305 -0.2613777 -0.2447111 -0.2408028 -1.048260
[2,] -3.0433899 -3.1306252 -2.6601367 -5.0275855 -2.596964
[3,] -3.8848651 -4.1398497 -3.6984915 -3.8832277 -6.917348
> 
> dmeasure(rw2,y=y[,1,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
            [,1]        [,2]       [,3]        [,4]
[1,] 0.130009525 0.099538380 0.12701912 0.058909910
[2,] 0.006314898 0.006087434 0.00545215 0.004457682
[3,] 0.000000000 0.000000000 0.00000000 0.000000000
> dmeasure(rw2,y=y[,2,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
             [,1]         [,2]         [,3]         [,4]
[1,] 9.495506e-19 4.639718e-07 0.0001862387 1.388155e-15
[2,] 1.302891e-03 4.868953e-03 0.0062363554 3.532405e-03
[3,] 0.000000e+00 0.000000e+00 0.0000000000 0.000000e+00
> log(dmeasure(rw2,y=y[,3,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p))
           [,1]      [,2]       [,3]       [,4]
[1,] -14.337877 -36.84944 -38.275846 -42.466689
[2,]  -5.556753  -7.28100  -5.747134  -5.499941
[3,]        Inf       Inf        Inf        Inf
> dmeasure(rw2,y=y[,3,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p,log=T)
           [,1]      [,2]       [,3]       [,4]
[1,] -14.337877 -36.84944 -38.275846 -42.466689
[2,]  -5.556753  -7.28100  -5.747134  -5.499941
[3,]        Inf       Inf        Inf        Inf
> 
> po <- pomp(
+            rprocess = rw.rprocess,
+            dprocess = rw.dprocess,
+            dmeasure = bvnorm.dmeasure,
+            rmeasure = bvnorm.rmeasure,
+            times=1:100,
+            data=rbind(
+              y1=rep(0,100),
+              y2=rep(0,100)
+              ),
+            t0=0
+            )
> 
> dmeasure(po,y=y[,1,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
            [,1]        [,2]       [,3]        [,4]
[1,] 0.130009525 0.099538380 0.12701912 0.058909910
[2,] 0.006314898 0.006087434 0.00545215 0.004457682
[3,] 0.000000000 0.000000000 0.00000000 0.000000000
> dmeasure(po,y=y[,2,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
             [,1]         [,2]         [,3]         [,4]
[1,] 9.495506e-19 4.639718e-07 0.0001862387 1.388155e-15
[2,] 1.302891e-03 4.868953e-03 0.0062363554 3.532405e-03
[3,] 0.000000e+00 0.000000e+00 0.0000000000 0.000000e+00
> log(dmeasure(po,y=y[,3,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p))
           [,1]      [,2]       [,3]       [,4]
[1,] -14.337877 -36.84944 -38.275846 -42.466689
[2,]  -5.556753  -7.28100  -5.747134  -5.499941
[3,]        Inf       Inf        Inf        Inf
> dmeasure(po,y=y[,3,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p,log=T)
           [,1]      [,2]       [,3]       [,4]
[1,] -14.337877 -36.84944 -38.275846 -42.466689
[2,]  -5.556753  -7.28100  -5.747134  -5.499941
[3,]        Inf       Inf        Inf        Inf
> 
> data(rw2)
> 
> dmeasure(po,y=y[,1,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
            [,1]        [,2]       [,3]        [,4]
[1,] 0.130009525 0.099538380 0.12701912 0.058909910
[2,] 0.006314898 0.006087434 0.00545215 0.004457682
[3,] 0.000000000 0.000000000 0.00000000 0.000000000
> dmeasure(po,y=y[,2,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p)
             [,1]         [,2]         [,3]         [,4]
[1,] 9.495506e-19 4.639718e-07 0.0001862387 1.388155e-15
[2,] 1.302891e-03 4.868953e-03 0.0062363554 3.532405e-03
[3,] 0.000000e+00 0.000000e+00 0.0000000000 0.000000e+00
> dmeasure(po,y=y[,3,1:4],x=x[,,1:4,drop=F],times=time(rw2)[1:4],p,log=T)
           [,1]      [,2]       [,3]       [,4]
[1,] -14.337877 -36.84944 -38.275846 -42.466689
[2,]  -5.556753  -7.28100  -5.747134  -5.499941
[3,]        Inf       Inf        Inf        Inf
> dprocess(rw2,x[,,6:11],times=5:10,params=p,log=T)
           [,1]       [,2]       [,3]       [,4]      [,5]
[1,] -0.3528305 -0.2613777 -0.2447111 -0.2408028 -1.048260
[2,] -3.0433899 -3.1306252 -2.6601367 -5.0275855 -2.596964
[3,] -3.8848651 -4.1398497 -3.6984915 -3.8832277 -6.917348
> 
> 
